---
title: Admin tutorial
---

This page is a guided walk-thru of common administration activities and features:

* View health of VMs
* Scale up and out to create more capacity
* Move a database to different VMs
* Find syslog logs various scenarios
* Destroy all VMs and recover from archives

The last section a very important section. **It is highly recommended** that all administrators practise this tutorial at least once so they are familiar and confident with the disaster recovery proceedings.

## View health of VMs

As an administrator of Pivotal OpsManager, you can SSH into its VM and access the running Dingo PostgreSQL using the `bosh` CLI.

```
$ ssh ubuntu@OPS-MANAGER-FQDN
Password: ***********
```

Once inside, target the BOSH director and login:

```
bosh --ca-cert /var/tempest/workspaces/default/root_ca_certificate target OPS-MANAGER-DIRECTOR-IP
bosh login
```

To find the Dingo PostgreSQL deployment name:

```
bosh deployments
```

The output will look similar to:

```
+---------------------------------------+---------------------------------+-
| Name                                  | Release(s)                      |
+---------------------------------------+---------------------------------+-
| cf-cfe388ed8196d69ce46c               | cf/235.5.50                     |
|                                       | ...                             |
+---------------------------------------+---------------------------------+-
| dingo-postgresql-a7b288b79dc61da71d3c | broker-registrar/2.0.0          |
|                                       | dingo-postgresql/0.10.0         |
|                                       | etcd/66                         |
|                                       | simple-remote-syslog/2.2.1      |
+---------------------------------------+---------------------------------+-
```

To poll for the health/vitals of Dingo PostgreSQL using the name above (using a small font and wide terminal window):

```
bosh vms dingo-postgresql-a7b288b79dc61da71d3c --vitals
```

The output's right hand side will show the utilization of RAM `Memory Usage` and persistent disk `Persistent Disk Usage`:

```
+--------------------------+---------+-------------+-----------------------+------+------+------+--------------+------------+------------+------------+------------+
| VM                       | State   | IPs         |         Load          | CPU  | CPU  | CPU  | Memory Usage | Swap Usage | System     | Ephemeral  | Persistent |
|                          |         |             | (avg01, avg05, avg15) | User | Sys  | Wait |              |            | Disk Usage | Disk Usage | Disk Usage |
+--------------------------+---------+-------------+-----------------------+------+------+------+--------------+------------+------------+------------+------------+
| cell_z1-partition-9ae... | running | 10.213.0.62 | 0.00, 0.03, 0.05      | 0.9% | 0.6% | 0.0% | 3% (463.0M)  | 0% (0B)    | 44%        | 0%         | 1%         |
| cell_z1-partition-9ae... | running | 10.213.0.63 | 0.06, 0.05, 0.05      | 1.0% | 0.5% | 0.0% | 3% (464.3M)  | 0% (0B)    | 44%        | 0%         | 1%         |
| cell_z2-partition-9ae... | running | 10.213.0.64 | 0.00, 0.02, 0.05      | 0.3% | 0.3% | 0.1% | 3% (448.5M)  | 0% (0B)    | 44%        | 0%         | 1%         |
| cell_z2-partition-9ae... | running | 10.213.0.65 | 0.00, 0.01, 0.05      | 0.2% | 0.2% | 0.0% | 3% (463.5M)  | 0% (0B)    | 44%        | 0%         | 1%         |
| etcd-partition-9ae6a1... | running | 10.213.0.61 | 0.05, 0.04, 0.05      | 0.0% | 0.0% | 0.3% | 5% (106.9M)  | 0% (0B)    | 44%        | 1%         | 3%         |
| router-partition-9ae6... | running | 10.213.0.66 | 0.03, 0.05, 0.05      | 0.5% | 0.6% | 0.0% | 6% (127.1M)  | 0% (0B)    | 44%        | 3%         | 0%         |
+--------------------------------------------+-----+----------------------------------------+-------------+-----------------------+------+------+------+--------------+------------+------------+------------+------------+
```

You are primarily focused on the health of the `cell` VMs. This is where PostgreSQL servers are running inside Docker containers.

## Access PostgreSQL servers inside Docker containers

Use the `bosh` CLI to SSH into one of the `cell` VMs:

```
bosh ssh cell_z1-partition-9ae6a1dc1415bea56862/0
```

Once inside, setup a `_docker` alias that references the local Docker daemon:

```
alias _docker="/var/vcap/packages/docker/bin/docker --host unix:///var/vcap/sys/run/docker/docker.sock"
```

To see the list of Docker containers running:

```
_docker ps
```

The example output below shows a single Docker container running a PostgreSQL server (one half of a highly available cluster):

```
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS                                              NAMES
19b6bc04a2fe        dingotiles/dingo-postgresql95:0.10.0   "dumb-init -c /script"   5 days ago          Up 5 days           0.0.0.0:32770->5432/tcp, 0.0.0.0:32771->8008/tcp   cf-51ac1400-3a73-452b-b531-db50f2084da1
88395eabc4c5        cfcommunity/registrator:latest         "/bin/registrator -ho"   5 days ago          Up 5 days                                                              registrator
```

The `cfcommunity/registrator:latest` container is an internal system component used by Dingo PostgreSQL for containers to discover their host information.

In the example above, the container `19b6bc04a2fe` has name `cf-51ac1400-3a73-452b-b531-db50f2084da1`.

To open a shell inside the container, use either the name or ID for a container. The following are interchangeable:

```
_docker exec -ti 19b6bc04a2fe bash
_docker exec -ti cf-51ac1400-3a73-452b-b531-db50f2084da1 bash
```

Once inside the Docker container, to view a hierarchical list of processes running:

```
root@19b6bc04a2fe:~# ps axwf
  PID TTY      STAT   TIME COMMAND
 3377 ?        S<s    0:00 bash
 3405 ?        R<+    0:00  \_ ps axwf
    1 ?        S<s    0:00 dumb-init -c /scripts/run.sh
   10 ?        S<     0:00 sudo PATH=/usr/lib/postgresql/9.5/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin -E -u postgres /scripts/postgres
   73 ?        S<     0:00  \_ /bin/bash /scripts/postgres/start_pg.sh
   87 ?        S<l   23:18      \_ python /patroni.py /patroni/postgres.yml
   88 ?        S<     0:00      \_ /bin/bash /scripts/postgres/start_pg.sh
   92 ?        S<     0:05      |   \_ sed -u s/^/T-3228-patroni> /
  100 ?        S<     5:21      \_ /bin/bash /scripts/postgres/reinitialize_when_stalled.sh
 3404 ?        S<     0:00      |   \_ sleep 2
  101 ?        S<     2:39      \_ /bin/bash /scripts/postgres/self_advertize.sh
 3372 ?        S<     0:00          \_ sleep 6
   94 ?        S<     0:28 /bin/bash /scripts/postgres/regular_backup.sh
 3219 ?        S<     0:00  \_ sleep 30
   95 ?        S<     0:00 /bin/bash /scripts/postgres/regular_backup.sh
  102 ?        S<     0:04  \_ sed -u s/^/T-3228-backup> /
   98 ?        S<     3:51 /bin/bash /scripts/postgres/regular_backup.sh
 3359 ?        S<     0:00  \_ sleep 5
   99 ?        S<     0:00 /bin/bash /scripts/postgres/regular_backup.sh
  107 ?        S<     0:00  \_ sed -u s/^/T-3228-backup> /
20913 ?        S<     0:06 /usr/lib/postgresql/9.5/bin/postgres -D /data/postgres0 --listen_addresses=0.0.0.0 --port=5432 --hot_standby=on --listen_addresses=
20964 ?        S<s    0:01  \_ postgres: checkpointer process
20965 ?        S<s    0:00  \_ postgres: writer process
20966 ?        S<s    0:01  \_ postgres: stats collector process
20968 ?        S<s    0:20  \_ postgres: postgres postgres 127.0.0.1(50826) idle
21018 ?        S<s    0:01  \_ postgres: wal sender process appuser 10.213.0.64(50234) streaming 3/EE000060
21277 ?        S<s    0:00  \_ postgres: wal writer process
21278 ?        S<s    0:00  \_ postgres: autovacuum launcher process
21279 ?        S<s    0:00  \_ postgres: archiver process   last was 0000000C00000003000000ED
```

And there at the end is the `postgres` process and its child processes. The Docker container does not directly invoke `postgres`, rather it is a system called `patroni` that is responsible for initializing, configuring, and reconfiguring PostgreSQL.

## Scale up and out to create more capacity


## Move a database to different VMs


## Find syslog logs various scenarios

## Destroy all VMs and recover from archives

This is a very important section. **It is highly recommended** that all administrators practise this tutorial at least once so they are familiar and confident with the disaster recovery proceedings.
